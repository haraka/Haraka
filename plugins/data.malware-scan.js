// scan SHA256/SHA1/MD5 at:
// 1. MALWARE HASH REGISTRY
// 2. more coming soon

var version = '0.1.3';

var fs = require('fs');
var dns = require('dns');
var path = require('path');
var crypto = require('crypto');
var querystring = require('querystring');
var http = require('http');
var https = require('https');

var utils = require('./utils');

var async = require('async');

exports.register = function () {
    this.load_config();

    this.register_hook('data_post', 'wait_for_attachment_hooks');
    this.register_hook('data_post', 'check_attachments');
};

exports.load_config = function () {
    var plugin = this;

    plugin.cfg = plugin.config.get('data.malware-scan.ini', {
        booleans: [
            '-cymru.enabled',
            '-virustotal.enabled',
            '-metascan.enabled',
        ]
    },
    function () {
        plugin.load_config();
    });

    // normalize the config settings once when we read the file (instead of
    // millions of times during mail processing)
    if (plugin.cfg.cymru.check_hash) {
        plugin.cfg.cymru.check_hash =
        plugin.cfg.cymru.check_hash.toLowerCase();
    }
    else {
        plugin.cfg.cymru.check_hash = 'sha1';
    }

    if (plugin.cfg.virustotal.check_hash) {
        plugin.cfg.virustotal.check_hash =
        plugin.cfg.virustotal.check_hash.toLowerCase();
    }
    else {
        plugin.cfg.virustotal.check_hash = 'sha256';
    }

    if (plugin.cfg.metascan.check_hash) {
        plugin.cfg.metascan.check_hash =
        plugin.cfg.metascan.check_hash.toLowerCase();
    }
    else {
        plugin.cfg.metascan.check_hash = 'sha256';
    }
};

exports.start_attachment = function (connection, ctype, filename, body, stream) {
    var plugin = this;
    var txn = connection.transaction;

    function next() {
        if (txn.notes.attachment_count === 0 && txn.notes.attachment_next) {
            return txn.notes.attachment_next();
        }
        return;
    }

    // Calculate and report the md5 of each attachment
    var md5 = crypto.createHash('md5');
    var sha1 = crypto.createHash('sha1');
    var sha256 = crypto.createHash('sha256');
    var digest_md5;
    var digest_sha1;
    var digest_sha256;
    var bytes = 0;
    stream.on('data', function (data) {
        bytes += data.length;
        md5.update(data);
        sha1.update(data);
        sha256.update(data);
    });
    stream.once('end', function () {
        digest_md5 = md5.digest('hex');
        digest_sha1 = sha1.digest('hex');
        digest_sha256 = sha256.digest('hex');
        var ca = ctype.match(/^(.*)?;\s+name="(.*)?"/);
        txn.results.push(plugin, {
            attach : {
                file : filename,
                ctype : (ca && ca[2] === filename) ? ca[1] : ctype,
                md5 : digest_md5,
                sha1 : digest_sha1,
                sha256 : digest_sha256,
                bytes : bytes,
            },
        });
        connection.loginfo(plugin, 'file="' + filename + '" ctype="' +
            ctype + '" md5=' + digest_md5 + ' sha1=' + digest_sha1 + ' sha256=' + digest_sha256);
    });
};

exports.hook_data = function (next, connection) {
    var plugin = this;
    var txn = connection.transaction;
    txn.parse_body = 1;
    txn.notes.attachment_count = 0;
    txn.attachment_hooks(function (ctype, filename, body, stream) {
        plugin.start_attachment(connection, ctype, filename, body, stream);
    });

    return next();
};

exports.getHashObj = function getHashObj(filesList){
    var hashes = {
        md5: [],
        sha1: [],
        sha256: []
    };

    for (var i = 0, d = filesList.length; i < d; i++){
        hashes.md5.push(filesList[i].md5);
        hashes.sha1.push(filesList[i].sha1);
        hashes.sha256.push(filesList[i].sha256);
    }

    return hashes;
};

exports.check_attachments = function (next, connection) {
    var plugin = this;
    var txn = connection.transaction;

    // Check for any stored errors from the attachment hooks
    if (txn.notes.attachment_result) {
        var result = txn.notes.attachment_result;
        connection.logerror(plugin, 'check_attachments ' + JSON.stringify(result));
        return next(result[0], result[1]);
    }

    var data = txn.results.get('data.malware-scan');

    if (data && data.attach && data.attach.length > 0){
        // get hashlist with object of md5, sha1 and sha256 keys as array
        var hashList = plugin.getHashObj(data.attach);
    }
    else { // no data? then skip
        connection.logdebug(plugin, 'no attachment to scan');
        return next();
    }

    var services = [];
    var services_hash = [];

    if (plugin.cfg.cymru.enabled) {
        services.push(plugin.team_cymru_check);
        services_hash.push(hashList[plugin.cfg.cymru.check_hash]);
    }
    if (plugin.cfg.virustotal.enabled) {
        services.push(plugin.virustotal_check);
        services_hash.push(hashList[plugin.cfg.virustotal.check_hash]);
    }
    if (plugin.cfg.metascan.enabled) {
        services.push(plugin.metascan_online_check);
        services_hash.push(hashList[plugin.cfg.metascan.check_hash]);
    }

    if (services.length > 0) {
        var asyncJob = [];
        var i;
        var s;
        for (i = 0, s = services.length; i < s; i++){
            asyncJob.push((services[i](services_hash[i], plugin, connection)));
        }
        // Run scan jobs and if one service match deny_results or
        // deny_percentage returned by a TRUE, DENY the mail.
        async.parallel(asyncJob, function (err, results) {
            if (results.indexOf(true) !== -1){
                return next(DENY, 'Message contains unacceptable attachment (MALWARE)');
            }
            return next();
        });

    }
    else { // no service enabled? then skip
        connection.logdebug(plugin, 'Plugin loaded, but no service is enabled');
        return next();
    }
};


exports.team_cymru_check = function (hashlist, plugin, conn) {
    if (!plugin) plugin = this;
    var apikey = plugin.cfg.cymru.apikey || false;

    return function(cb){

        /*
        // current not implemented
        if (!apikey) {
            conn.logerror(plugin, 'no APIKEY for cymru found');
            return cb(null, false);
        }
        */
        if (!hashlist || hashlist.length === 0) {
            conn.logerror(plugin, 'no hashlist for cymru found');
            return cb(null, false);
        }

        var cymru_hashes = [];
        var next_done = false;
        var i;
        var j;
        for (i = 0, j = hashlist.length; i < j; i++) {
            cymru_hashes.push(function (callback) {
                dns.resolve(hashlist[i] + '.malware.hash.cymru.com', 'TXT', function (err, result) {
                    if (result) {
                        return callback(null, result.split(" ")[1]);
                    }
                    return callback(null, -1);
                });
            });
        }

        async.parallel(cymru_hashes, function (err, results) {

            if (results.length > 1){
                // Order from large to small
                results.sort(function sortNumber(a, b) {
                    return a - b;
                });
            }

            // use only the largest result
            if (results[0] >= plugin.cfg.cymru.deny_percentage) {
                if (!next_done) {
                    next_done = true;
                    return cb(null, true);
                }
            }
            else {
                if (!next_done) {
                    next_done = true;
                    return cb(null, false);
                }
            }
        });
    };
};


exports.virustotal_check = function (hashlist, plugin, conn) {
    if (!plugin) plugin = this;
    var apikey  = plugin.cfg.virustotal.apikey || false;
    var deny_results  = plugin.cfg.virustotal.deny_results || 2;

    return function(cb){

        if (!apikey) {
            conn.logerror(plugin, 'no APIKEY for virustotal found');
            return cb(null, false);
        }
        if (!hashlist || hashlist.length === 0){
            conn.logerror(plugin, 'no hashlist for virustotal found');
            return cb(null, false);
        }

        var chunk_list = plugin.chunkArray(hashlist);
        var jobs = [];
        var i;
        var j;
        for (i = 0, j = chunk_list.length; i < j; i++) {
            jobs.push(plugin.virustotal_check_post(chunk_list[i], plugin, conn));
        }

        async.parallel(jobs, function (err, jobResults) {
            if (jobResults.indexOf(true) !== -1){
                return cb(null, true);
            }
            return cb(null, false);
        });
    };
};

exports.virustotal_check_post = function (hashlist, plugin, conn){
    if (!plugin) plugin = this;
    var apikey  = plugin.cfg.virustotal.apikey || false;
    var deny_results  = plugin.cfg.virustotal.deny_results || 2;

    return function(cb){
        var post_data = querystring.stringify({
            'resources' : hashlist,
            'apikey' : apikey
        });

        // An object of options to indicate where to post to
        var post_options = {
            host : 'api.vtapi.net',
            port : '80',
            path : '/vtapi/get_file_reports.json',
            method : 'POST',
            headers : {
                'Content-Type' : 'application/x-www-form-urlencoded',
                'Content-Length' : post_data.length
            }
        };

        // Set up the request
        var post_req = http.request(post_options, function (res) {
            res.setEncoding('utf8');
            res.on('data', function (chunk) {
                try {
                    if (res.statusCode !== 200){
                        conn.logerror(plugin, 'virustotal failure: ' + res.statusCode + ' - ' + res.statusMessage);
                        return cb(null, false);
                    }

                    var results = JSON.parse(chunk);
                    if (results && typeof results === "object" && results !== null) {

                        // get the heighest result of all results
                        if (plugin.getResultsByVT(results) >= deny_results){
                            return cb(null, true);
                        }
                        else {
                            return cb(null, false);
                        }

                    }
                } catch (err) {
                    conn.logerror(plugin, 'virustotal failure: ' + err);
                    return cb(null, false);
                }
            });
            res.on('error', function (err) {
                conn.logerror(plugin, 'virustotal failure: ' + err);
                return cb(null, false);
            });
        });

        // post the data and end;
        post_req.end(post_data);
    };
};

exports.getResultsByVT = function (vtData){
    var results = [];
    var helper;
    var i;
    var vt;

    for (i = 0, vt = vtData.length; i < vt; i++ ){
        if (vtData[i].report){
            helper = vtData[i].report;
        }
        else {
            helper = vtData[i];
        }
        results[i] = 0;

        if (helper.result === 0) continue;

        for (var prop in helper) {
            if (helper.hasOwnProperty(prop) && helper[prop] !== null){
                results[i]++;
            }
        }

    }

    if (!results.length)
        return 0;

    results.sort(function(a,b){return b - a;});
    return results[0];
};


exports.metascan_online_check = function (hashlist, plugin, conn) {
    if (!plugin) plugin = this;
    var apikey  = plugin.cfg.metascan.apikey || false;
    var deny_results  = plugin.cfg.metascan.deny_results || 2;

    return function(cb){

        if (!apikey) {
            conn.logerror(plugin, 'no APIKEY for metascan found');
            return cb(null, false);
        }
        if (!hashlist || hashlist.length === 0) {
            conn.logerror(plugin, 'no hashlist for metascan found');
            return cb(null, false);
        }

        var post_data = JSON.stringify({
            'hash' : hashlist
        });

        // An object of options to indicate where to post to
        var post_options = {
            host : 'hashlookup.metascan-online.com',
            port : '443',
            path : '/v2/hash',
            method : 'POST',
            headers : {
                'Content-Type' : 'application/x-www-form-urlencoded',
                'Content-Length' : post_data.length,
                'apikey' : apikey
            }
        };

        // Set up the request
        var post_req = https.request(post_options, function (res) {
            res.setEncoding('utf8');
            res.on('data', function (chunk) {
                try {
                    if (res.statusCode !== 200){
                        conn.logerror(plugin, 'metascan failure: ' + res.statusCode + ' - ' + res.statusMessage);
                        return cb(null, false);
                    }

                    var results = JSON.parse(chunk);
                    if (results && typeof results === "object" && results !== null) {

                        if (results.err){
                            conn.logerror(plugin, 'metascan failure: ' + results.err);
                            return cb(null, false);
                        }

                        if (plugin.getResultsByMetascan(results) >= deny_results){
                            return cb(null, true);
                        }
                        else {
                            return cb(null, false);
                        }

                    }
                } catch (err) {
                    conn.logerror(plugin, 'metascan failure: ' + err);
                    return cb(null, false);
                }
            });
            res.on('error', function (err) {
                conn.logerror(plugin, 'metascan failure: ' + err);
                return cb(null, false);
            });
        });

        // post the data and end;
        post_req.end(post_data);
    };
};

exports.getResultsByMetascan = function getResultsByMetascan(msData){
    var results = [];
    var disallowed_results = { '1':'1','2':'2','8':'8' }; // faster to scan
    for (var i = 0, ms = msData.length; i < ms; i++ ){
        var helper = msData[i];
        if (typeof disallowed_results[helper.scan_result] !== "undefined") { // faster to scan
            results[i] = Number(helper.scan_result);
        }
    }

    if (!results.length)
        return 0;

    results.sort(function(a,b){return b - a;});
    return results[0];
};

exports.chunkArray = function chunkArray(list, chunk) {
    var i
    var j;
    var chunk = chunk || 25;
    var temparray = [];
    for (i = 0, j = list.length; i < j; i += chunk) {
        temparray.push(list.slice(i, i + chunk));
    }
    return temparray;
};

exports.wait_for_attachment_hooks = function (next, connection) {
    var txn = connection.transaction;
    if (txn.notes.attachment_count > 0) {
        // We still have attachment hooks running
        txn.notes.attachment_next = next;
    }
    else {
        next();
    }
};